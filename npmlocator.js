// Generated by LiveScript 1.3.1
(function(){
  var isFilePath, fetchUrl, checkUrl, resolvePackage, resolveFileUrl, resolveFile, resolvePath, resolveNodeModule, parentPath, joinPath, builtins, myPath, ref$, builtinsPath, builtinsPromise, nodeResolve, promiseNodeResolve, doNodeResolve, rawNodeResolve, oldNormalize, slice$ = [].slice;
  
    var isWorker = typeof window == 'undefined' && typeof self != 'undefined' && typeof importScripts != 'undefined';
    var isBrowser = typeof window != 'undefined' && typeof document != 'undefined';
    var isWindows = typeof process != 'undefined' && !!process.platform.match(/^win/);
    var fetchTextFromURL;
    if (typeof XMLHttpRequest != 'undefined') {
      fetchTextFromURL = function(url, fulfill, reject) {
        // percent encode just '#' in urls
        // according to https://github.com/jorendorff/js-loaders/blob/master/browser-loader.js#L238
        // we should encode everything, but it breaks for servers that don't expect it
        // like in (https://github.com/systemjs/systemjs/issues/168)
        if (isBrowser)
          url = url.replace(/#/g, '%23');
  
        var xhr = new XMLHttpRequest();
        var sameDomain = true;
        var doTimeout = false;
        if (!('withCredentials' in xhr)) {
          // check if same domain
          var domainCheck = /^(\w+:)?\/\/([^\/]+)/.exec(url);
          if (domainCheck) {
            sameDomain = domainCheck[2] === window.location.host;
            if (domainCheck[1])
              sameDomain &= domainCheck[1] === window.location.protocol;
          }
        }
        if (!sameDomain && typeof XDomainRequest != 'undefined') {
          xhr = new XDomainRequest();
          xhr.onload = load;
          xhr.onerror = error;
          xhr.ontimeout = error;
          xhr.onprogress = function() {};
          xhr.timeout = 0;
          doTimeout = true;
        }
        function load() {
          fulfill(xhr.responseText);
        }
        function error() {
          reject(xhr.statusText + ': ' + url || 'XHR error');
        }
  
        xhr.onreadystatechange = function () {
          if (xhr.readyState === 4) {
            if (xhr.status === 200 || (xhr.status == 0 && xhr.responseText)) {
              load();
            } else {
              error();
            }
          }
        };
        xhr.open("GET", url, true);
  
        if (doTimeout)
          setTimeout(function() {
            xhr.send();
          }, 0);
  
        xhr.send(null);
      };
    }
    else if (typeof require != 'undefined') {
      var fs;
      fetchTextFromURL = function(url, fulfill, reject) {
        if (url.substr(0, 8) != 'file:///')
          throw 'Only file URLs of the form file:/// allowed running in Node.';
        fs = fs || require('fs');
        if (isWindows)
          url = url.replace(/\//g, '\\').substr(8);
        else
          url = url.substr(7);
        return fs.readFile(url, function(err, data) {
          if (err)
            return reject(err);
          else {
            // Strip Byte Order Mark out if it's the leading char
            var dataString = data + '';
            if (dataString[0] === '\ufeff')
              dataString = dataString.substr(1);
  
            fulfill(dataString);
          }
        });
      };
    }
    else {
      throw new TypeError('No environment fetch API available.');
    }
  
  isFilePath = function(name){
    if (name[0] === '/') {
      return true;
    }
    if (name.substring(0, 2) === './') {
      return true;
    }
    if (name.substring(0, 3) === '../') {
      return true;
    }
    return false;
  };
  fetchUrl = function(url, method){
    method == null && (method = 'GET');
    return new Promise(function(accept, reject){
      return fetchTextFromURL(url.toString(), accept, reject);
    });
  };
  checkUrl = function(url){
    return fetchUrl(url, 'HEAD');
  };
  resolvePackage = function(pkg){
    return fetchUrl(joinPath(pkg, "package.json")).then(function(data){
      var main, ref$;
      main = (ref$ = JSON.parse(data).main) != null ? ref$ : 'index';
      if (main[main.length - 1] === '/') {
        main += "index";
      }
      return resolveFile(joinPath(pkg, main));
    });
  };
  resolveFileUrl = function(url){
    return checkUrl(url).then(function(){
      return url;
    });
  };
  resolveFile = function(path){
    return resolveFileUrl(path)['catch'](function(){
      return resolveFileUrl(path + ".js");
    });
  };
  resolvePath = function(path){
    return resolvePackage(path)['catch'](function(){
      return resolveFile(path);
    });
  };
  resolveNodeModule = function(name, path){
    path == null && (path = '');
    return resolvePackage(joinPath(path, 'node_modules', name))['catch'](function(){
      var ppath, ref$;
      ppath = parentPath(path);
      while ((ref$ = ppath.pathname.split('/'))[ref$.length - 1] === 'node_modules') {
        ppath = parentPath(ppath);
      }
      return resolveNodeModule(name, ppath);
    });
  };
  parentPath = function(path){
    var parts;
    path = new URL(path);
    parts = path.pathname.split('/');
    parts = parts.filter(function(p){
      return p !== '' && p !== '.';
    });
    if (parts.length === 0) {
      throw new Error("No parent path for '" + path + "'");
    }
    parts.pop();
    path.pathname = parts.join('/');
    path.search = '';
    path.hash = '';
    return path;
  };
  joinPath = function(base){
    var parts;
    parts = slice$.call(arguments, 1);
    base = new URL(base);
    parts = parts.filter(function(p){
      return p !== '' && p !== '.';
    });
    parts.unshift(base.pathname);
    base.pathname = parts.join('/');
    base.pathname = base.pathname.normalize();
    return base;
  };
  builtins = void 8;
  myPath = parentPath((ref$ = document.getElementsByTagName('script'))[ref$.length - 1].src);
  builtinsPath = joinPath(myPath, 'node_modules/browser-builtins');
  builtinsPromise = fetchUrl(joinPath(builtinsPath, 'package.json')).then(function(data){
    var conf;
    conf = JSON.parse(data);
    return builtins = conf.browser;
  }).then(function(){
    return System['import']("buffer");
  }).then(function(buffer){
    return window.Buffer = buffer.Buffer;
  });
  nodeResolve = function(){
    var args, orig;
    args = slice$.call(arguments);
    orig = Promise.resolve(promiseNodeResolve.apply(null, args));
    return orig.then(function(path){
      return path;
    });
  };
  promiseNodeResolve = function(){
    var args;
    args = slice$.call(arguments);
    if (builtins == null) {
      return builtinsPromise.then(function(){
        return doNodeResolve.apply(null, args);
      });
    }
    return doNodeResolve.apply(null, args);
  };
  doNodeResolve = function(name, parent){
    if (name in builtins) {
      return rawNodeResolve(builtins[name], joinPath(builtinsPath, 'dummy'));
    }
    return rawNodeResolve(name, parent);
  };
  rawNodeResolve = function(name, parent){
    var dir;
    if (parent == null) {
      dir = new URL(System.baseURL);
    } else {
      dir = parentPath(new URL(parent));
    }
    if (isFilePath(name)) {
      return resolvePath(joinPath(dir, name));
    }
    return resolveNodeModule(name, dir);
  };
  oldNormalize = System.normalize;
  System.normalize = function(path, parent){
    var oargs, parts, plugins;
    oargs = arguments;
    parts = path.split('!');
    path = parts[0], plugins = slice$.call(parts, 1);
    if (System.map && path in System.map) {
      path = System.map[path];
    }
    parent = parent != null ? parent.split("!")[0] : void 8;
    return nodeResolve(path, parent).then(function(normed){
      var result;
      result = [normed].concat(plugins).join("!");
      return result;
    });
  };
}).call(this);
